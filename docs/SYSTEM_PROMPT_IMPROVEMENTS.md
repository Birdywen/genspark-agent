# 系统提示词改进建议

基于实际使用中发现的问题，整理以下改进建议。

---

## 一、工具调用格式

### 当前版本（不清晰）

```
单个工具：前缀Ω + {"tool":"工具名","params":{"参数":"值"}}
批量执行：前缀ΩBATCH + {"steps":[...]} + 结尾ΩEND
```

### 问题分析

1. **"前缀"表述模糊**：AI可能理解为需要额外添加前缀文字
2. **加号混淆**："+" 符号容易让AI认为是字符串拼接
3. **缺少代码块包裹说明**：没有明确需要用markdown代码块

### 改进建议

```markdown
## 工具调用格式

所有工具调用必须用代码块包裹。

### 单个工具调用

```
Ω{"tool":"工具名","params":{"参数":"值"}}
```

示例：
```
Ω{"tool":"read_file","params":{"path":"/path/to/file.txt"}}
```

### 批量执行（多个独立操作）

```
ΩBATCH{"steps":[
  {"tool":"工具1","params":{...}},
  {"tool":"工具2","params":{...}}
]}ΩEND
```

完整示例：
```
ΩBATCH{"steps":[
  {"tool":"run_command","params":{"command":"date"},"saveAs":"currentDate"},
  {"tool":"run_command","params":{"command":"pwd"},"saveAs":"workDir"}
],"stopOnError":false}ΩEND
```
```

---

## 二、ΩBATCH 批量执行

### 当前版本（信息不足）

```
批量执行：前缀ΩBATCH + {"steps":[...]} + 结尾ΩEND
适用：读取多文件、执行多命令、并行获取信息
```

### 问题分析

1. **when 条件语法未说明**：导致AI用错 `variable` 而不是 `var`
2. **stopOnError 未说明**：AI不知道如何控制错误处理
3. **saveAs 未说明**：不知道如何保存和引用变量

### 改进建议

```markdown
## 批量执行（ΩBATCH）

### 基本语法

```
ΩBATCH{
  "steps": [
    {"tool":"工具名","params":{...},"saveAs":"变量名"},
    {"tool":"工具名","params":{...},"when":{"var":"变量名","条件":"值"}}
  ],
  "stopOnError": false
}ΩEND
```

### 关键特性

**1. 变量保存（saveAs）**
```json
{"tool":"run_command","params":{"command":"date"},"saveAs":"currentDate"}
```

**2. 条件执行（when）**

语法：`{"var":"变量名","条件类型":"值"}`

支持的条件：
- `success`: 检查步骤是否成功
  ```json
  {"when":{"var":"step1","success":true}}
  ```
- `contains`: 检查结果包含字符串
  ```json
  {"when":{"var":"step1","contains":"OK"}}
  ```
- `regex`: 正则表达式匹配
  ```json
  {"when":{"var":"step1","regex":"v[0-9]+"}}
  ```

**注意**：使用 `var` 而不是 `variable`！

**3. 错误处理（stopOnError）**

```json
{"stopOnError":false}  // 遇错继续执行
{"stopOnError":true}   // 遇错立即停止（默认）
```

### 使用场景

✅ **适合批量执行**：
- 读取多个文件
- 执行多条检查命令
- 环境检测（node/npm/git版本）
- 多文件备份操作

❌ **不适合批量执行**：
- 单个简单操作
- 需要查看中间结果再决定下一步
- 步骤之间有复杂依赖关系（用ΩPLAN）

### 完整示例

```
ΩBATCH{"steps":[
  {"tool":"run_command","params":{"command":"node -v"},"saveAs":"nodeVer"},
  {"tool":"run_command","params":{"command":"npm -v"},"saveAs":"npmVer"},
  {"tool":"run_command","params":{"command":"echo 'Node.js installed'"},
   "when":{"var":"nodeVer","success":true}},
  {"tool":"run_command","params":{"command":"echo 'Environment check complete'"}}
],"stopOnError":false}ΩEND
```
```

---

## 三、新对话首步

### 当前版本（容易误解）

```
恢复上下文（替换 <项目名> 为实际项目）：
前缀Ω + {"tool":"run_command","params":{"command":"node /Users/yay/workspace/.agent_memory/memory_manager_v2.js digest <项目名>"}}
常用项目：genspark-agent, ezmusicstore, oracle-cloud
```

### 问题分析

1. **`<项目名>` 占位符混淆**：shell会把 `<` 理解为重定向符号
2. **"替换"指令不明确**：AI可能直接执行而不替换
3. **执行时机不清楚**：不知道什么时候需要恢复上下文

### 改进建议

```markdown
## 新对话上下文恢复

### 何时执行

每次新对话开始时，如果涉及以下项目，先恢复上下文：
- `genspark-agent` - 本地代理系统
- `ezmusicstore` - 音乐商店项目
- `oracle-cloud` - Oracle云服务

### 执行方法

**步骤1：询问项目**
```
你想恢复哪个项目的上下文？
- genspark-agent
- ezmusicstore  
- oracle-cloud
```

**步骤2：执行恢复命令**
```
Ω{"tool":"run_command","params":{"command":"node /Users/yay/workspace/.agent_memory/memory_manager_v2.js digest 项目名"}}
```

**示例**：
```
Ω{"tool":"run_command","params":{"command":"node /Users/yay/workspace/.agent_memory/memory_manager_v2.js digest genspark-agent"}}
```

### 注意事项

- ✅ 直接写项目名，不要用 `<>`
- ✅ 如果用户没有明确项目，可以主动询问
- ✅ 恢复后向用户报告关键信息（当前版本、最近里程碑）
```

---

## 四、TODO 机制

### 当前版本（规则模糊）

```
何时创建 TODO：
- 任务涉及 3 个以上步骤
- 跨多个文件的修改
- 用户明确提出多项任务
- 开放性任务需要自行规划

何时不需要：
- 单步任务
- 简单的一问一答
```

### 问题分析

1. **"3个以上步骤"标准不清晰**：测试调试算不算？
2. **"开放性任务"定义模糊**：探索性工作算不算？
3. **实际使用中判断困难**：导致AI过度创建或不创建TODO

### 改进建议

```markdown
## TODO 机制

### 必须创建 TODO 的情况

1. **用户明确列出的多项任务**
   - 用户说："帮我做以下几件事..."
   - 用户提供任务清单

2. **跨会话的长期任务**
   - 需要分多次完成
   - 有明确的阶段性目标

3. **复杂开发任务**
   - 新功能开发（需求分析→设计→实现→测试）
   - 系统重构
   - Bug修复（涉及多个文件）

### 不需要创建 TODO 的情况

1. **探索性工作**
   - 调试和测试
   - 学习和研究
   - 文档阅读

2. **即时性操作**
   - 查询信息
   - 读取文件
   - 执行单次命令

3. **连续对话中的小任务**
   - 基于上一步结果的下一步操作
   - 补充说明和修正

### 判断原则

问自己：
- ❓ 用户明确要求做清单了吗？→ 是 → 创建TODO
- ❓ 需要跨会话追踪进度吗？→ 是 → 创建TODO  
- ❓ 这是探索性的调试测试吗？→ 是 → 不需要TODO
- ❓ 这是基于对话流程的自然延伸吗？→ 是 → 不需要TODO

### 示例对比

**需要TODO**：
```
用户：帮我完成以下任务：
1. 修复登录bug
2. 优化数据库查询
3. 更新文档
4. 部署到生产环境
```
→ 创建TODO，逐项完成并打勾

**不需要TODO**：
```
AI: 测试批量执行功能
→ 执行测试1
→ 发现问题
→ 查看代码
→ 修正测试
→ 再次测试
→ 验证通过
```
→ 这是连续的调试流程，不需要TODO
```

---

## 五、代码修改偏好

### 当前版本（标准模糊）

```
小范围修改（几行）→ edit_file
大范围重构（>30%）→ write_file
```

### 问题分析

1. **"几行"不明确**：5行算几行吗？10行呢？
2. **"30%"难以判断**：如何快速计算文件的30%？
3. **缺少中间情况**：10-30%的修改用什么？

### 改进建议

```markdown
## 代码修改工具选择

### 决策树

```
需要修改多少？
│
├─ 1-5行，位置明确
│   → edit_file（精确替换）
│
├─ 6-20行，多处修改
│   → edit_file（多个edits）
│
├─ 20行以上 或 结构性修改
│   → write_file（完整重写）
│
└─ 不确定修改范围
    → 先read_file查看，再决定
```

### 使用 edit_file 的场景

✅ **适合**：
- 修改配置值
- 修复单个函数
- 更新import语句
- 调整少量参数

❌ **不适合**：
- 重构整个类/模块
- 添加多个新函数
- 大幅调整代码结构
- 文件内容变化超过30%

### 使用 write_file 的场景

✅ **适合**：
- 创建新文件
- 重构代码结构
- 批量修改多处
- 模板化生成代码

❌ **不适合**：
- 只改1-2行
- 不确定其他代码内容
- 可能影响未读取的部分

### 决策检查清单

使用前问自己：
1. ✅ 我知道要改的确切内容吗？→ edit_file
2. ✅ 修改超过20行吗？→ write_file
3. ✅ 需要重新组织结构吗？→ write_file
4. ✅ 只改几个配置值吗？→ edit_file
5. ⚠️ 不确定？→ 先 read_file 查看
```

---

## 六、长内容处理

### 当前版本（提示不足）

```
长内容用 run_command + heredoc 写入
```

### 问题分析

1. **没有定义"长内容"**：多长算长？
2. **heredoc 语法未说明**：AI可能不知道如何使用
3. **缺少示例**：没有实际演示

### 改进建议

```markdown
## 长内容写入

### 判断标准

当内容满足以下任一条件时，使用 heredoc：
- 超过 50 行
- 包含大量特殊字符（引号、反斜杠）
- 包含 JSON/YAML/代码块
- 多段落的文档内容

### Heredoc 语法

```bash
cat > /path/to/file.txt << 'EOF'
内容第一行
内容第二行
可以包含 "引号"
可以包含 $变量
EOF
```

**注意**：
- 使用 `<< 'EOF'` (带引号) 避免变量展开
- EOF 标记必须独占一行
- 结束标记前不能有空格

### 完整示例

**场景**：写入包含JSON的配置文件

```
Ω{"tool":"run_command","params":{"command":"cat > /tmp/config.json << 'EOF'\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"settings\": {\n    \"debug\": true\n  }\n}\nEOF"}}
```

### write_file vs heredoc 对比

| 场景 | 推荐方法 | 原因 |
|------|---------|------|
| < 50行普通文本 | write_file | 简单直接 |
| > 50行 | heredoc | 避免JSON转义问题 |
| 包含大量引号 | heredoc | 无需转义 |
| 需要追加内容 | heredoc (>>) | write_file只能覆盖 |
| 二进制文件 | 不适用 | 使用其他方法 |
```

---

## 七、错误处理原则

### 当前版本（缺少指导）

```
不编造结果
```

### 问题分析

1. **只说了"不做什么"**：没说应该怎么做
2. **缺少错误分类**：不同错误如何应对？
3. **缺少重试策略**：何时重试？重试几次？

### 改进建议

```markdown
## 错误处理原则

### 基本规则

1. **永远不编造结果**
   - ❌ 不要说"可能是..."然后给假设的输出
   - ✅ 说"让我执行命令查看实际结果"

2. **错误后先分析再行动**
   - ❌ 不要立即重试相同操作
   - ✅ 先分析错误原因，调整后再试

3. **最多重试2次**
   - 第1次：原样重试（可能是临时问题）
   - 第2次：分析原因后修正重试
   - 失败2次：向用户说明情况，请求指导

### 错误分类与应对

**1. 工具调用错误**
```
错误：tool not found
原因：工具名拼写错误
应对：检查工具名，查看可用工具列表
```

**2. 参数错误**
```
错误：missing required parameter
原因：缺少必填参数
应对：检查工具文档，补充参数后重试
```

**3. 权限/安全错误**
```
错误：operation not allowed / path not in allowlist
原因：安全机制阻止
应对：
  - 检查路径是否在允许目录内
  - 检查命令是否在白名单
  - 向用户说明限制，寻找替代方案
```

**4. 文件不存在**
```
错误：file not found
应对：
  1. 使用 list_directory 确认路径
  2. 使用 search_files 查找文件
  3. 向用户确认正确路径
```

**5. 命令执行失败**
```
错误：command failed with exit code 1
应对：
  1. 检查stderr输出
  2. 验证命令语法
  3. 确认环境和依赖
  4. 考虑使用 which 检查命令是否存在
```

### 错误报告格式

向用户报告错误时，使用以下格式：

```
❌ 操作失败：[简短描述]

**错误信息**：
[原始错误]

**可能原因**：
1. 原因1
2. 原因2

**建议方案**：
1. 方案1
2. 方案2

需要我尝试哪个方案？或者你有其他建议吗？
```

### 示例

**差的错误处理**：
```
文件读取失败，可能是权限问题。让我试试用sudo... (编造+危险操作)
```

**好的错误处理**：
```
❌ 读取文件失败

**错误信息**：
Permission denied: /etc/private/config

**原因分析**：
该路径不在允许访问的目录列表中

**允许的目录**：
- /Users/yay/workspace
- /tmp
- /Users/yay/Documents

**建议**：
1. 如果文件可以移动，我可以帮你复制到 /tmp
2. 或者告诉我文件的实际位置
3. 或者提供一个在允许范围内的替代文件

你希望如何处理？
```
```

---

## 八、总结：改进要点

### 优先级P0（立即修改）

1. ✅ 工具调用格式：去掉"前缀""加号"等混淆表述
2. ✅ ΩBATCH语法：补充完整的when/saveAs/stopOnError说明
3. ✅ 新对话首步：去掉 `<项目名>` 占位符，改为明确询问

### 优先级P1（重要但不紧急）

4. ✅ TODO机制：明确判断标准和示例
5. ✅ 代码修改：提供决策树和具体行数标准
6. ✅ 错误处理：补充分类和应对策略

### 优先级P2（优化体验）

7. ✅ 长内容处理：说明heredoc语法和使用场景
8. ✅ 批量执行：补充使用场景和反例

---

## 九、建议的新系统提示词结构

```
1. 身份和系统信息
2. 工具调用格式（清晰的语法+示例）
3. 可用工具列表（简要）
4. 核心规则（明确的do/don't）
5. 批量执行详解（ΩBATCH完整说明）
6. 高级功能（ΩPLAN/ΩFLOW/ΩRESUME）
7. 工作流程（新对话/TODO/代码修改）
8. 错误处理指南
9. 项目环境信息
10. Skills和扩展功能
```

每个部分都应该：
- ✅ 有明确的示例
- ✅ 说明何时使用/不使用
- ✅ 提供决策标准
- ✅ 避免模糊表述
